eval()
    执行一段字符串中的JavaScript代码
结构
    eval(code)
参数
    code
        包含待求值的JavaScript表达式或待执行的JavaScript语句的字符串
返回
    求值后的代码的值，如果存在对应的值的话。
异常
    如果code不是合法的JavaScript代码，则将抛出一个SyntaxError。如果在对code求值的过程中发生了错误，则eval()将传播这个错误。
说明
    eval()是一个用于执行一段JavaScript代码字符串的全局方法。如果code包含一个表达式，则eval()将对表达式求值并返回一个值。（一些表达式（如看起来像语句的对象和函数直接量）早传入eval()时必须包含在圆括号中以消除多义性）如果code包含一条或多条JavaScript语句，则eval()将执行这些语句，并由最后一个语句返回对应值。如果code不返回任何值，则eval()将返回undefined。最后，如果code抛出异常，则eval()将把这个异常传递给调用函数。
    在ES3和ES5中，eval()行为不同，甚至在ES5中，严格模式和非严格模式下的也不同。
    如果一门编程语言将eval()定义为一个操作符而不是一个函数，那么实现高效的解释器会容易很多。JavaScript的eval()是一个函数，出于效率的考虑，它在直接、类似操作符一样调用和非直接调用eval之间做了区分。直接调用是指直接使用标识符eval()。如果去掉圆括号，看起来就像是一个操作符。其它形式的eval()的调用都是非直接调用。如果将eval()函数赋值给一个名字不同的变量，并通过变量调用它，这也是一种非直接调用。类似的，如果将eval()作为全局对象的一个方法来调用，它也是一种非直接调用。
    根据直接和非直接调用的差别。如需啊
    直接调用，ES3及ES5非严格模式
        eval()在当前词法作用域内对code求值。如果code包含变量或函数声明，则将在本地作用域中定义他们。这是eval()的普通用例。
    非直接调用，ES3
        ES3标准允许解释器对任何eval()的非直接调用抛出一个EvalError。ES3的实现实际上一般没有这么做，但是应该避免非直接调用
    非直接调用，ES5
        ES5中，对eval()的非直接调用不在出现EvalError，但code必须在全局作用域中求值，当前词法作用域的任何本地变量豆浆忽略。在ES5中，可以这样赋值：“var geval = eval”；然后使用geval()来在全局作用域中对code求值。
    直接或非直接调用，严格模式
        在严格模式中，code中定义的变量和函数将在一个私有作用域中定义，这个私有作用域仅在调用该eval()期间有效，这就意味着，在严格模式下直接调用eval()将不能该变词法作用域，在严格模式下的非直接调用不能更改全局作用域。当对eval()的调用在严格模式下，或者如果code以‘use strict’指令开始，这些个规则将会生效。
        
    在JavaScript语言中，eval()提供了非常强大的的功能，但实际项目中使用的不多。常用的包括编写作为递归的JavaScript解释器的程序，以及编写动态生成并判断JavaScript代码的程序。
    对于大多数期望参数传入字符串参数的函数来讲，在执行真正的逻辑时，不管传入的参数是什么类型都会线转换为字符串。eval()则不会这样，如果传入的参数不是字符串原始值，它会直接返回这个值。因此，当传入一个字符串对象给eval()时就需要非常小心了。这时应当传入一个字符串原始值才对。